<?php

/*
* Check the password against a hash generated by the generate_hash
* function.
*
* (c) 2014 Marten Jacobs, public domain
*/
function validate_pw($password, $hash){
  /* Regenerating the hash with an available hash as the options parameter should
   * produce the same hash if the same password is passed.
   */
  return crypt($password, $hash)==$hash;
}

/*
* Generate a secure hash for a given password. The cost is passed
* to the blowfish algorithm. Check the PHP manual page for crypt to
* find more information about this setting.
*
* (c) 2014 Marten Jacobs, public domain
*/
function generate_hash($password, $cost=11){
  /* To generate the salt, first generate enough random bytes. Because
   * base64 returns one character for each 6 bits, the we should generate
   * at least 22*6/8=16.5 bytes, so we generate 17. Then we get the first
   * 22 base64 characters
   */
  $salt=substr(base64_encode(openssl_random_pseudo_bytes(17)),0,22);
  /* As blowfish takes a salt with the alphabet ./A-Za-z0-9 we have to
   * replace any '+' in the base64 string with '.'. We don't have to do
   * anything about the '=', as this only occurs when the b64 string is
   * padded, which is always after the first 22 characters.
   */
  $salt=str_replace("+",".",$salt);
  /* Next, create a string that will be passed to crypt, containing all
   * of the settings, separated by dollar signs
   */
  $param='$'.implode('$',array(
      "2y", //select the most secure version of blowfish (>=PHP 5.3.7)
      str_pad($cost,2,"0",STR_PAD_LEFT), //add the cost in two digits
      $salt //add the salt
  ));
  //now do the actual hashing
  return crypt($password,$param);
}

function valid_password() {
  global $passwords_file, $post_data, $name, $debug;

  $json = file_get_contents($passwords_file);
  $passwords = json_decode($json, true);

  if (isset($passwords[$name]) && !empty($passwords[$name])) {
    if ($debug) var_dump($passwords);

    $saved = $passwords[$name];
    $given = $post_data['password'];
    if ($debug) {
      $hashed = generate_hash($post_data['password']);
      var_dump(array('saved' => $saved, 'given' => $given, 'hashed' => $hashed));
    }

    if (validate_pw($given, $saved)) {
      // correct password, proceed
      return true;

    } else {
      // incorrect, return error
      return false;
    }
  } else {
    // set password
    $password = generate_hash($post_data['password']);
    $passwords[$name] = $password;

    file_put_contents($passwords_file, json_encode($passwords));
    return true;
  }
}

function get_partner() {
  global $name, $storage, $debug;

  if (file_exists($storage)) {
    // read files
    $json = file_get_contents($storage);
    $data = json_decode($json, true);

  } else {
    global $names;
    // create a shuffled list
    $shuffled = shuffle_names($names);
    
    if ($debug) {
      //echo('$shuffled'); var_dump($shuffled); echo("<br />\n");
    }
    foreach ($names as $key => $value) {
      $data[$value] = $shuffled[$key];
    }

    $json = json_encode($data);
    file_put_contents($storage, $json);
  }
  if ($debug) var_dump($data);
  return $data[$name];
}

function shuffle_names($in) {
  global $debug;

  if ($debug) {
    echo('$in'); var_dump($in); echo("<br />\n");
  }

  do {
    $shuffled = $in;
    shuffle($shuffled);
    if ($debug) echo("shuffled\n");

    $duplicates = false;

    for ($i=count($in) -1; $i >= 0; $i--) {
      if ($in[$i] == $shuffled[$i]) {
        if ($debug) echo($i . ": " . $in[$i] . " = " . $shuffled[$i] . "\n");
        $duplicates = true;
        break;
      }
    }
  } while ($duplicates);

  return $shuffled;
}
